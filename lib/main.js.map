{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/main.coffee"
  ],
  "names": [],
  "mappings": "AAEA;EAAA;AAAA,MAAA,GAAA,EAAA,KAAA,EAAA,KAAA,EAAA,MAAA,EAAA,QAAA,EAAA,gBAAA,EAAA,GAAA,EAAA,OAAA,EAAA,IAAA,EAAA,QAAA,EAAA,iBAAA,EAAA,IAAA;;;EAIA,GAAA,GAA4B,OAAA,CAAQ,KAAR;;EAC5B,KAAA,GAA4B;;EAC5B,KAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,OAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAA,GAA4B,GAAG,CAAC,UAAJ,CAAe,MAAf,EAA4B,KAA5B;;EAC5B,IAAC,CAAA,KAAD,GAA4B,IAAI,CAAE,OAAA,CAAQ,WAAR,CAAF,CAAuB,CAAC,SAA5B,CAAA;;EAC5B,CAAA,CAAE,GAAF,EACE,QADF,EAEE,iBAFF,EAGE,OAHF,CAAA,GAG4B,IAAC,CAAA,KAAK,CAAC,MAAP,CAAA,CAH5B,EAVA;;;EAgBA,IAAC,CAAA,KAAK,CAAC,OAAP,CAAe,aAAf,EAA8B;IAAA,KAAA,EAC5B;MAAA,gBAAA,EAAsC,QAAA,CAAE,CAAF,CAAA;eAAS,IAAC,CAAA,GAAG,CAAC,MAAL,CAAY,CAAZ;MAAT,CAAtC;MACA,qDAAA,EAAwD,QAAA,CAAE,CAAF,CAAA;QACtD,IAAmB,kBAAnB;AAAA,iBAAO,KAAP;;AACA,eAAO,CAAE,IAAC,CAAA,GAAG,CAAC,aAAL,CAAmB,CAAC,CAAC,QAArB,CAAF,CAAA,IAAqC,CAAE,CAAE,IAAC,CAAA,GAAG,CAAC,MAAL,CAAY,CAAC,CAAC,QAAd,CAAF,CAAA,IAA+B,CAAC,CAAC,MAAF,GAAW,CAA5C;MAFU,CADxD;;MAKA,wBAAA,EAAsC,QAAA,CAAE,CAAF,CAAA;eAAS,IAAC,CAAA,YAAY,CAAC,OAAd,CAAsB,CAAC,CAAC,MAAxB;MAAT;IALtC;EAD4B,CAA9B,EAhBA;;;EAyBA,QAAA,GACE;IAAA,QAAA,EAAc,IAAd;IACA,MAAA,EAAc;EADd,EA1BF;;;EA8BA,IAAC,CAAA,WAAD,GAAe,QAAA,CAAE,QAAF,CAAA;IACb,iBAAiB,CAAC,WAAlB,CAA8B,QAA9B;IACA,QAAA,GAAsB,CAAE,GAAA,QAAF,EAAe,GAAA,QAAf;IACtB,QAAQ,CAAC,MAAT,GAAsB;IACtB,QAAQ,CAAC,SAAT,GAAsB;IACtB,IAA2D,GAAG,CAAC,IAAJ,CAAS,QAAQ,CAAC,QAAlB,CAA3D;MAAA,QAAQ,CAAC,QAAT,GAAwB,MAAM,CAAC,IAAP,CAAY,QAAQ,CAAC,QAArB,EAAxB;;AACA,WAAO;MAAE,SAAA,EAAW,IAAb;MAAmB,GAAA;IAAnB;EANM,EA9Bf;;;EAuCA,MAAA,GAAS,QAAA,CAAE,EAAF,EAAM,IAAN,CAAA;IACP,KAAmB,EAAE,CAAC,MAAtB;AAAA,aAAO,KAAP;;AACA,WAAO,IAAI,CAAC,QAAL,CAAc,OAAd;EAFA,EAvCT;;;EA4CA,gBAAA,GAAmB,QAAA,CAAE,MAAF,EAAU,QAAV,EAAoB,MAApB,CAAA;AACnB,QAAA,SAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA,GAAA,EAAA;IAAE,IAAa,MAAA,IAAU,MAAM,CAAC,MAA9B;AAAA,aAAO,CAAC,EAAR;;IACA,KAAS,iEAAT;MACE,IAAG,MAAM,CAAE,CAAF,CAAN,KAAe,QAAQ,CAAE,CAAF,CAA1B;QACE,IAAG,QAAQ,CAAC,MAAT,GAAkB,CAArB;UACE,SAAA,GAAY;UACZ,CAAA,GAAI;UACJ,CAAA,GAAI;AACJ,iBAAM,CAAA,GAAI,CAAA,GAAI,QAAQ,CAAC,MAAvB;YACE,IAAG,MAAM,CAAE,CAAF,CAAN,KAAiB,QAAQ,CAAE,CAAF,CAA5B;cACE,SAAA,GAAY;AACZ,oBAFF;;YAGA,CAAA;YACA,CAAA;UALF;UAMA,IAA8B,SAA9B;AAAA,mBAAO,CAAA,GAAI,QAAQ,CAAC,OAApB;WAVF;SAAA,MAAA;AAYE,gBAZF;SADF;;IADF;AAeA,WAAO,CAAA,GAAI,QAAQ,CAAC,MAAb,GAAsB;EAjBZ,EA5CnB;;;EAgEA,IAAC,CAAA,IAAD,GAAQ,QAAA,CAAE,EAAF,EAAM,CAAN,CAAA;AACR,QAAA,CAAA,EAAA,GAAA;;IACE,QAAQ,CAAC,MAAT,CAAgB,CAAhB;IACA,CAAA,GAAgB;IAChB,EAAE,CAAC,SAAH,GAAgB;IAChB,EAAE,CAAC,MAAH,GAAgB;IAChB,EAAE,CAAC,SAAH,GAAgB;IAChB,IAAG,oBAAH;MACE,CAAA,GAAgB,MAAM,CAAC,MAAP,CAAc,CAAE,EAAE,CAAC,SAAL,EAAgB,CAAhB,CAAd;MAChB,EAAE,CAAC,MAAH,GAAgB,EAAE,CAAC,SAAS,CAAC;MAC7B,EAAE,CAAC,SAAH,GAAgB,KAHlB;;AAIA,WAAA,IAAA;MACE,GAAA,GAAM,gBAAA,CAAiB,CAAjB,EAAoB,EAAE,CAAC,QAAvB,EAAiC,EAAE,CAAC,MAAH,GAAY,EAAE,CAAC,QAAQ,CAAC,MAAxB,GAAiC,CAAlE;MACN,IAAG,GAAA,IAAO,CAAP,IAAa,GAAA,GAAM,CAAC,CAAC,MAAxB;QACE,CAAC,CAAC,IAAF,CAAO,MAAA,CAAO,EAAP,EAAW,CAAC,CAAC,KAAF,CAAQ,EAAE,CAAC,SAAX,EAAsB,GAAtB,CAAX,CAAP;QACA,EAAE,CAAC,MAAH,GAAe,GAAA,GAAM,EAAE,CAAC,QAAQ,CAAC;QACjC,EAAE,CAAC,SAAH,GAAe,EAAE,CAAC,OAHpB;OAAA,MAAA;QAKE,EAAE,CAAC,SAAH,GAAgB,CAAC,CAAC,KAAF,CAAQ,EAAE,CAAC,SAAX;AAChB,cANF;;IAFF;AASA,WAAO;EApBD,EAhER;;;EAuFA,IAAC,CAAA,GAAD,GAAO,QAAA,CAAE,EAAF,CAAA;AACP,QAAA;IAAE,IAAG,oBAAH;MACE,CAAA,GAAgB,MAAA,CAAO,EAAP,EAAW,EAAE,CAAC,SAAd;MAChB,EAAE,CAAC,SAAH,GAAgB;AAChB,aAAO,CAAE,CAAF,EAHT;;AAIA,WAAO;EALF;AAvFP",
  "sourcesContent": [
    "\n\n'use strict'\n\n\n############################################################################################################\nCND                       = require 'cnd'\nbadge                     = 'INTERTEXT/SPLITLINES'\ndebug                     = CND.get_logger 'debug',     badge\nurge                      = CND.get_logger 'urge',      badge\nwarn                      = CND.get_logger 'warn',      badge\n@types                    = new ( require 'intertype' ).Intertype()\n{ isa\n  validate\n  validate_optional\n  type_of }               = @types.export()\n\n#-----------------------------------------------------------------------------------------------------------\n@types.declare 'sl_settings', tests:\n  'x is an object':                     ( x ) -> @isa.object x\n  'x.?splitter is a nonempty_text or a nonempty buffer':  ( x ) ->\n    return true unless x.splitter?\n    return ( @isa.nonempty_text x.splitter ) or ( ( @isa.buffer x.splitter ) and x.length > 0 )\n  ### TAINT use `encoding` for better flexibility ###\n  'x.?decode is a boolean':             ( x ) -> @isa_optional.boolean x.decode\n\n#-----------------------------------------------------------------------------------------------------------\ndefaults =\n  splitter:     '\\n'\n  decode:       true\n\n#-----------------------------------------------------------------------------------------------------------\n@new_context = ( settings ) ->\n  validate_optional.sl_settings settings\n  settings            = { defaults..., settings..., }\n  settings.offset     = 0\n  settings.lastMatch  = 0\n  settings.splitter   = ( Buffer.from settings.splitter ) if isa.text settings.splitter\n  return { collector: null, settings..., }\n\n#-----------------------------------------------------------------------------------------------------------\ndecode = ( me, data ) ->\n  return data unless me.decode\n  return data.toString 'utf-8'\n\n#-----------------------------------------------------------------------------------------------------------\nfind_first_match = ( buffer, splitter, offset ) ->\n  return -1 if offset >= buffer.length\n  for i in [ offset ... buffer.length ] by +1\n    if buffer[ i ] is splitter[ 0 ]\n      if splitter.length > 1\n        fullMatch = true\n        j = i\n        k = 0\n        while j < i + splitter.length\n          if buffer[ j ] isnt splitter[ k ]\n            fullMatch = false\n            break\n          j++\n          k++\n        return j - splitter.length if fullMatch\n      else\n        break\n  return i + splitter.length - 1\n\n#-----------------------------------------------------------------------------------------------------------\n@send = ( me, d ) ->\n  ### thx to https://github.com/maxogden/binary-split/blob/master/index.js ###\n  validate.buffer d\n  R             = []\n  me.collector  = null\n  me.offset     = 0\n  me.lastMatch  = 0\n  if me.collector?\n    d             = Buffer.concat [ me.collector, d, ]\n    me.offset     = me.collector.length\n    me.collector  = null\n  loop\n    idx = find_first_match d, me.splitter, me.offset - me.splitter.length + 1\n    if idx >= 0 and idx < d.length\n      R.push decode me, d.slice me.lastMatch, idx\n      me.offset    = idx + me.splitter.length\n      me.lastMatch = me.offset\n    else\n      me.collector  = d.slice me.lastMatch\n      break\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\n@end = ( me ) ->\n  if me.collector?\n    R             = decode me, me.collector\n    me.collector  = null\n    return [ R, ]\n  return []\n\n"
  ]
}